var Promise = require('bluebird');
var crypto = Promise.promisifyAll(require('crypto'));
var util = require('util');

var _ = require('lodash');

var conf;

/**
 * Simple and extendable password utility class.
 * @class Passworks
 *
 * @return {this}
 *
 * @param {object} options 						Password options.
 * @param {string} options.strategy 	The key of the strategy to use when digest() is called.
 * @param {string} options.algorithm 	The algorithm to be used(SHA1, SHA256, SHA512)
 * @param {number} options.iterations	The number of hash iterations.
 * @param {number} options.keyLength 		The byte length of the key. Used for salt and digest.
 */
function Passworks(options) {
	if (typeof conf !== 'object') {
		throw new TypeError('Expected conf to be an object. Use Passworks.init(conf) first.');
	}

	_.defaults(this, options, conf);

	if (!this.salt) {
		this.salt = Passworks.genSalt.call();
	}

	return this;
}

/**
 * Generate a salt using the current keyLength.
 *
 * @return {string} The salt string.
 *
 * @memberof Passworks
 * @method genSalt
 */
Passworks.genSalt = function salt(keyLength) {
	var keyLengthLocal = keyLength || conf.keyLength;

	return crypto.randomBytes(parseInt(keyLengthLocal, 10)).toString('hex');
};

/**
 * Perform the hashing operation using the configured strategy.
 * @param  {string} 	password 		The password to be hashed.
 * @param  {Boolean} 	returnHash 	Whether to return, or set, the resultant hash string.
 *
 * @return {Promise} Resolved as either this, or the hash string when returnHash.
 *
 * @memberof Passworks
 * @method digest
 */
Passworks.prototype.digest = function digest(password, returnHash) {
	if (!this.strategies[this.strategy]) {
		return Promise.reject(new Passworks.StrategyError('Invalid strategy: "' + this.strategy + '"'));
	}

	return Promise.resolve(this.strategies[this.strategy].call(this, password))
		.bind(this)
		.then(function resolveHash(hash) {
			if (returnHash) return hash;

			this.hash = hash;

			return this;
		});
};

/**
 * Validate whether a string matches the current hash.
 * @param  {string} 	password	The password to compare.
 * @return {Promise} 						Resolves to this, or rejects with an Error.
 *
 * @memberof Passworks
 * @method matches
 */
Passworks.prototype.matches = function matches(password) {
	return this.digest(password, true)
		.then(function verify(verifyHash) {
			return verifyHash === this.hash
				? Promise.resolve(this).bind(this)
				: Promise.reject(new Passworks.PasswordError('Password does not match'));
		}.bind(this));
};

/**
 * Return the current instance as a string. Useful to persist to a database.
 * @return {string} 	A : delimited string of the pattern strategy:algorithm:iterations:keyLength:salt:hash
 *
 * @memberof Passworks
 * @method toString
 */
Passworks.prototype.toString = function toString() {
	var passwordParts = [
		this.strategy,
		this.algorithm,
		this.iterations,
		this.keyLength,
		this.salt,
		this.hash
	];

	return passwordParts.join(':');
};

Passworks.prototype.toObject = function toObject() {
	return {
		strategy: this.strategy,
		algorithm: this.algorithm,
		iterations: this.iterations,
		keyLength: this.keyLength,
		salt: this.salt,
		hash: this.hash
	};
};

/**
 * Create a new instance from a string generated by toString
 *
 * @param  {string} passwordString 	A : delimited string containing the options, hash, and salt.
 * @return {object} 								A new Passworks instance.
 *
 * @memberof Passworks
 * @method fromString
 */
Passworks.fromString = function fromString(passwordString) {
	var passwordParts = (passwordString || '').split(':');
	var options = {};

	if (passwordParts.length === 6) {
		options = {
			strategy: passwordParts[0],
			algorithm: passwordParts[1],
			iterations: parseInt(passwordParts[2], 10),
			keyLength: parseInt(passwordParts[3], 10),
			salt: passwordParts[4],
			hash: passwordParts[5]
		};
	} else {
		throw new Passworks.Error('passwordString must contain 6 parts demilited by :');
	}

	return new Passworks(options);
};

Passworks.fromObject = function fromObject(passwordObject) {
	var options = {
		strategy: passwordObject.strategy,
		algorithm: passwordObject.algorithm,
		iterations: passwordObject.iterations,
		keyLength: passwordObject.keyLength,
		salt: passwordObject.salt,
		hash: passwordObject.hash
	};

	return new Passworks(options);
};

/**
 * Set up the config for new instances.
 * @param  {object} initConf The configuration to set for new Passworks instances.
 *
 * @memberof Passworks
 * @method init
 */
Passworks.init = function init(initConf) {
	conf = initConf;
};

Passworks.Error = function PassworksError(message) {
	Error.call(this);
	this.message = message;
};
util.inherits(Passworks.Error, Error);

Passworks.PasswordError = function PasswordError(message) {
	Error.call(this);
	this.message = message;
};
util.inherits(Passworks.PasswordError, Passworks.Error);

Passworks.StrategyError = function StrategyError(message) {
	Error.call(this);
	this.message = message;
};
util.inherits(Passworks.StrategyError, Passworks.Error);

Passworks.prototype.strategies = {};

/**
 * Add a new strategy.
 * @param {string}   strategy 	The string to be used as the key for the strategy.
 * @param {Function} fn 				The function to be used by digest().
 *
 * @memberof Passworks
 * @method addStrategy
 */
Passworks.addStrategy = function addStrategy(strategy, fn) {
	if (Passworks.prototype.strategies.hasOwnProperty(strategy)) {
		throw new Passworks.StrategyError('Strategy "' + strategy + '" already exists.');
	}
	if (typeof fn !== 'function') {
		throw new Passworks.StrategyError('Expected second argument "fn" to be a function.');
	}

	Passworks.prototype.strategies[strategy] = fn;
};

var defaultStrategies = {
	pbkdf2: function pbkdf2(password, returnHash) {
		var args = [
			password,
			this.salt,
			this.iterations,
			parseInt(this.keyLength, 10)
		];

		if (crypto.pbkdf2.length === 6) {
			args.push(this.algorithm);
		}

		return crypto.pbkdf2Async.apply(null, args)
			.call('toString', 'hex');
	}
};

Object.keys(defaultStrategies).forEach(function eachStrategy(strategy) {
	Passworks.addStrategy(strategy, defaultStrategies[strategy]);
});

module.exports = Passworks;
