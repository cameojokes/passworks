var Promise = require('bluebird');
var crypto = Promise.promisifyAll(require('crypto'));

var _ = require('lodash');

var conf;

/**
 * Simple and extendable password utility class.
 * @class Passworks
 *
 * @return {this}
 *
 * @param {object} options 						Password options.
 * @param {string} options.strategy 	The key of the strategy to use when digest() is called.
 * @param {string} options.algorithm 	The algorithm to be used(SHA1, SHA256, SHA512)
 * @param {number} options.iterations	The number of hash iterations.
 * @param {number} options.keyLen 		The byte length of the key. Used for salt and digest.
 */
function Passworks(options) {
	if (typeof conf !== 'object') {
		throw new TypeError('Expected conf to be an object. Use Passworks.init(conf) first.');
	}

	_.defaults(this, options, conf);

	if (!this.salt) {
		this.salt = this.genSalt();
	}

	return this;
}

/**
 * Generate a salt using the current keyLen.
 *
 * @return {string} The salt string.
 *
 * @memberof Passworks
 * @method genSalt
 */
Passworks.prototype.genSalt = function salt() {
	return crypto.randomBytes(parseInt(conf.keyLen, 10)).toString('hex');
};

/**
 * Perform the hashing operation using the configured strategy.
 * @param  {string} 	password 		The password to be hashed.
 * @param  {Boolean} 	returnHash 	Whether to return, or set, the resultant hash string.
 *
 * @return {Promise} Resolved as either this, or the hash string when returnHash.
 *
 * @memberof Passworks
 * @method digest
 */
Passworks.prototype.digest = function digest(password, returnHash) {
	return Promise.resolve(this.strategies[this.strategy].apply(this, arguments))
		.bind(this)
		.then(function resolveHash(hash) {
			if (returnHash) return hash;

			this.hash = hash;

			return this;
		});
};

/**
 * Validate whether a string matches the current hash.
 * @param  {string} 	password	The password to compare.
 * @return {Promise} 						Resolves to this, or rejects with an Error.
 *
 * @memberof Passworks
 * @method matches
 */
Passworks.prototype.matches = function matches(password) {
	return this.digest(password, true)
		.then(function verify(verifyHash) {
			return verifyHash === this.hash
				? Promise.resolve(this).bind(this)
				: Promise.reject(new Error('Password does not match'));
		}.bind(this));
};

/**
 * Return the current instance as a string. Useful to persist to a database.
 * @return {string} 	A : delimited string of the pattern strategy:algorithm:iterations:keyLen:salt:hash
 *
 * @memberof Passworks
 * @method toString
 */
Passworks.prototype.toString = function toString() {
	var passwordParts = [
		this.strategy,
		this.algorithm,
		this.iterations,
		this.keyLen,
		this.salt,
		this.hash
	];

	return passwordParts.join(':');
};

/**
 * Create a new instance from a string generated by toString
 *
 * @param  {string} passwordString 	A : delimited string containing the options, hash, and salt.
 * @return {object} 								A new Passworks instance.
 *
 * @memberof Passworks
 * @method fromString
 */
Passworks.fromString = function fromString(passwordString) {
	var passwordParts = passwordString.split(':');
	var options = {};

	if (passwordParts.length === 6) {
		options = {
			strategy: passwordParts[0],
			digest: passwordParts[1],
			iterations: parseInt(passwordParts[2], 10),
			keyLen: parseInt(passwordParts[3], 10),
			salt: passwordParts[4],
			hash: passwordParts[5]
		};
	} else {
		throw new RangeError('passwordString must contain 6 parts demilited by :');
	}

	return new Passworks(options);
};

/**
 * Set up the config for new instances.
 * @param  {object} initConf The configuration to set for new Passworks instances.
 *
 * @memberof Passworks
 * @method init
 */
Passworks.init = function init(initConf) {
	conf = initConf;
};

Passworks.prototype.strategies = {};

/**
 * Add a new strategy.
 * @param {string}   strategy 	The string to be used as the key for the strategy.
 * @param {Function} fn 				The function to be used by digest().
 *
 * @memberof Passworks
 * @method addStrategy
 */
Passworks.addStrategy = function addStrategy(strategy, fn) {
	if (Passworks.prototype.strategies.hasOwnProperty(strategy)) {
		throw new RangeError('Strategy "' + strategy + '" already exists.');
	}

	Passworks.prototype.strategies[strategy] = fn;
};

var defaultStrategies = {
	pbkdf2: function pbkdf2(password, returnHash) {
		return crypto.pbkdf2Async(password, this.salt, this.iterations, parseInt(this.keyLen, 10))
			.call('toString', 'hex');
	}
};

Object.keys(defaultStrategies).forEach(function eachStrategy(strategy) {
	Passworks.addStrategy(strategy, defaultStrategies[strategy]);
});

module.exports = Passworks;
